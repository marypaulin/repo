Algorithm


(d_c, R_c) = (None, 1) #Initialize best rule list and objective
Q = queue([(-r,r) for r in range(1,nrule+1)]) # initialize the queue to include all trees of just one split

for t in Q do
	if Risk(t)<R_c then
		(d_c, R_c) = (t, Risk(t)) # update best rule list and objective
	end if
end for

While Q not empty do
	tree = Q.pop()
	d = tree.get_prefix()
	
	if d has already been visited then
		continue
	else
		mark d as visited
	end if
	
	# the leaves we are going to split
	split_next = tree.get_splitleaf().copy()
	spl = split_next.pop(0)


	for every leaf i in d do
		
		if leaf i is dead then # a dead leaf means we won't split this leaf, because of the support bound
			continue
		end if
		
		if support bound of leaf i does NOT hold do
			mark leaf i as dead
			continue
		end if

		# for each tree, there is a queue of binary vector
		# indicating each leaf to be split pr not
		#if leaf i is marked as not split then continue
		if spl[i]==0 then
			continue
		end if

		# we are going to split leaf i, and get 2 new leaves
		# we will add the two new leaves to the end of the list
		splitleaf_list = [split_next[k][:i]+split_next[k][i+1:]+split_next[k][i:i+1]*2
							for k in range(len(split_next))]

		d0 = d[i] #d0 is the leaf i
		dp = d[:i]+d[i+1:] #dp is the rest

		for every feature s in S if s is not in the path from root to d0 do
			split d0 with s, get two new leaves l1,l2 and a new tree t
			
			if t has already been visited then
				continue
			end if


			sl = splitleaf_list.copy()
			splitleaf1 = [1]*(len(t)) #all leaves labeled as to be split
			splitleaf2 = [0]*(len(t)-2)+[1,1] #l1,l2 labeled as to be split
			splitleaf3 = [1]*(len(t)-2)+[0,0] #dp labeled as to be split

			if bound+b0+lamb>=R_c or lb>=R_c do
				# if equivalent points bound combined with the lookahead bound doesn't hold
				# or if the hierarchical objective lower bound doesn't hold
				# we need to split at least one leaf in dp
				if accurate antecedent support bound< LAMBDA do
					# if accurate antecedent support bound doesn't hold
					# we need to split at least one of l1,l2
					if at least one leaf in dp will have been split do
						if at least one of l1,l2 will have been split do
							#mark every leaf of t as to be split
							#push it into the split queue
							sl.append(splitleaf1)
						else
							#mark l1,l2 as to be split
							#push it into the split queue
							sl.append(splitleaf2)
						end if
					else
						if at least one of l1,l2 will have been split do
							#mark every leaf of dp as to be split
							#push it into the split queue
							sl.append(splitleaf3)
						else
							#mark l1,l2 as to be split
							#mark every leaf of dp as to be split
							#push it into the split queue
							sl.append(splitleaf2)
							sl.append(splitleaf3)
						end if
					end if
				else
					if at least one leaf in dp will have been split do
						#mark every leaf of t as to be split
						#push it into the split queue
						sl.append(splitleaf1)
					else
						#mark every leaf of dp as to be split
						#push it into the split queue
						sl.append(splitleaf3)
				end if
			else
				# if equivalent points bound combined with the lookahead bound doesn't hold
				# or if the hierarchical objective lower bound doesn't hold
				# we need to split at least one leaf in dp
				if accurate antecedent support bound< LAMBDA do
					# if accurate antecedent support bound doesn't hold
					# we need to split at least one of l1,l2
					if at least one of l1,l2 will have been split do
						#mark every leaf of t as to be split
						#push it into the split queue
						sl.append(splitleaf1)
					else
						#mark l1,l2 as to be split
						#push it into the split queue
						sl.append(splitleaf2)
					end if
				else
					#mark every leaf of t as to be split
					#push it into the split queue
					sl.append(splitleaf1)
			end if

			construct tree_new with t as encoded leaves and sl marking leaves to be split
			Q.push(tree_new)
			if Risk(tree_new)<R_c then
				(d_c, R_c) = (t, Risk(tree_new)) # update best rule list and objective
			end if
	end for
end while